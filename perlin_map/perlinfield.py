from perlin_map.perlin import Perlin
from utils.interpolate import smooth
import numpy as np


class Field:
    # A field initialized with a function
    def __init__(self, shape, func, x_scale=1, y_scale=1, x_0=0, y_0=0):
        def load_coordinates(x_size, y_size, increment):
            x = np.transpose(np.tile(np.arange(x_size) / increment, (y_size, 1)))
            y = np.tile(np.arange(y_size) / increment, (x_size, 1))
            return x, y
        self.shape = shape
        self.main_x, self.main_y = load_coordinates(shape[0], shape[1], 1)
        new_func = lambda x, y: func((x - x_0) / x_scale, (y - y_0) / y_scale)
        self.out = new_func(self.main_x, self.main_y)


# A generalized Perlin field with gradient descent built in
class PerlinField:
    def __init__(self, image, cell_shape, starting_field=None):
        self.image = image
        self.cell_shape = cell_shape
        self.out = np.zeros(cell_shape)
        self.shape, self.cell_size = image.shape, image.shape[0] // cell_shape[0]
        self.x_size, self.y_size = image.shape[0], image.shape[1]
        cell_shape = (self.x_size // self.cell_size, self.y_size // self.cell_size)

        # mag and dxn arrays are the essential data of the PerlinField
        self.mag = np.ones((cell_shape[0] + 1, cell_shape[1] + 1))
        self.dxn = 2*np.pi*np.random.rand(cell_shape[0] + 1, cell_shape[1] + 1)

        self.mag_grad = np.zeros(self.shape)
        self.dxn_grad = np.zeros(self.shape)
        self.error = np.zeros(self.shape)

        def load_coordinates(x_size, y_size, increment):
            x = np.transpose(np.tile(np.arange(x_size) / increment, (y_size, 1)))
            y = np.tile(np.arange(y_size) / increment, (x_size, 1))
            return x, y

        # Coordinate arrays
        self.delta = (cell_shape[0] / image.shape[0], cell_shape[1] / image.shape[1])
        self.d = (image.shape[0] // cell_shape[0], image.shape[1] // cell_shape[1])
        self.main_x, self.main_y = load_coordinates(self.x_size, self.x_size, 1)
        self.cells_x, self.cells_y = (self.main_x // self.cell_size).astype(int), (self.main_y // self.cell_size).astype(int)  # Mapping from coordinate to cell index
        self.unit_x, self.unit_y = load_coordinates(self.cell_size, self.cell_size,
                                                    self.cell_size)
        self.unit_x = np.tile(self.unit_x, cell_shape)
        self.unit_y = np.tile(self.unit_y, cell_shape)

        # Placeholders for calculating gradient descent
        t = (1 - smooth(self.unit_x)) * (1 - smooth(self.unit_y))  # upper left
        self.s00 = np.dstack((t * self.unit_x, t * self.unit_y))
        t = (1 - smooth(1 - self.unit_x)) * (1 - smooth(self.unit_y))  # upper right
        self.s10 = np.dstack((t * (self.unit_x - 1), t * self.unit_y))
        t = (1 - smooth(self.unit_x)) * (1 - smooth(1 - self.unit_y))  # lower left
        self.s01 = np.dstack((t * self.unit_x, t * (self.unit_y - 1)))
        t = (1 - smooth(1 - self.unit_x)) * (1 - smooth(1 - self.unit_y))  # lower right
        self.s11 = np.dstack((t * (self.unit_x - 1), t * (self.unit_y - 1)))


    # Updates self.out by calculating the raster generated by the gradients
    def render(self):
        # Empty grid
        grid = np.mgrid[0:self.cell_shape[0]:self.delta[0], 0:self.cell_shape[1]:self.delta[1]].transpose(1, 2, 0) % 1
        gradients = np.dstack((np.cos(self.dxn) * self.mag, np.sin(self.dxn) * self.mag))
        gradients = gradients.repeat(self.d[0], 0).repeat(self.d[1], 1)

        n00 = np.sum(np.dstack((grid[:, :, 0], grid[:, :, 1])) * gradients[:-self.d[0], :-self.d[1]], 2)
        n10 = np.sum(np.dstack((grid[:, :, 0] - 1, grid[:, :, 1])) * gradients[self.d[0]:, :-self.d[1]], 2)
        n01 = np.sum(np.dstack((grid[:, :, 0], grid[:, :, 1] - 1)) * gradients[:-self.d[0], self.d[1]:], 2)
        n11 = np.sum(np.dstack((grid[:, :, 0] - 1, grid[:, :, 1] - 1)) * gradients[self.d[0]:, self.d[1]:], 2)

        t = smooth(grid)
        n0 = n00 * (1 - t[:, :, 0]) + t[:, :, 0] * n10
        n1 = n01 * (1 - t[:, :, 0]) + t[:, :, 0] * n11
        grid = np.sqrt(2) * ((1 - t[:, :, 1]) * n0 + t[:, :, 1] * n1)

        self.out = grid

    def quick_rgb(self):
        val = self.out * 128
        return np.array(np.dstack((val, val, val)), dtype=np.uint8)

    def update_error(self):
        self.error = self.image - self.out

    def total_error(self):
        return 0.5 * np.sum(self.error * self.error, axis=None)

    # Gradient is computed based on magnitude and direction of each Perlin gradient vector
    def compute_gradient(self):
        l = self.cell_size
        cos, sin = np.cos(self.dxn), np.sin(self.dxn)
        i, j = self.cells_x, self.cells_y

        # Direction components of gradient descent rely on tangent
        tangents = np.dstack((self.mag * sin * -1, self.mag * cos))
        g00 = self.error * np.sum(self.s00 * tangents[i, j], axis=2) * self.mag[i, j]
        g10 = self.error * np.sum(self.s10 * tangents[i + 1, j], axis=2) * self.mag[i + 1, j]
        g01 = self.error * np.sum(self.s01 * tangents[i, j + 1], axis=2) * self.mag[i, j + 1]
        g11 = self.error * np.sum(self.s11 * tangents[i + 1, j + 1], axis=2) * self.mag[i + 1, j + 1]

        # Here we may want to put a weight on
        def dump_cell(i, j, gradient):
            # Weight can be set to a sigmoid function to avoid making excessively large steps
            weight = lambda x: x #np.arctan(x)
            gradient[i, j] += np.sum(weight(g00[i * l:(i + 1) * l, j * l:(j + 1) * l]), axis=None)
            gradient[i + 1, j] += np.sum(weight(g10[i * l:(i + 1) * l, j * l:(j + 1) * l]), axis=None)
            gradient[i, j + 1] += np.sum(weight(g01[i * l:(i + 1) * l, j * l:(j + 1) * l]), axis=None)
            gradient[i + 1, j + 1] += np.sum(weight(g11[i * l:(i + 1) * l, j * l:(j + 1) * l]), axis=None)

        self.dxn_grad = np.zeros(self.dxn.shape)
        for j in range(self.y_size // l):
            for i in range(self.x_size // l):
                dump_cell(i, j, self.dxn_grad)
        self.dxn_grad /= (self.cell_size ** 2)

        if False:
            # Magnitude components of gradient descent rely on normal
            normals = np.dstack((self.mag * cos, self.mag * sin))
            g00 = self.error * np.sum(self.s00 * normals[j, i], axis=2)
            g10 = self.error * np.sum(self.s10 * normals[j, i + 1], axis=2)
            g01 = self.error * np.sum(self.s01 * normals[j + 1, i], axis=2)
            g11 = self.error * np.sum(self.s11 * normals[j + 1, i + 1], axis=2)

            self.mag_grad = np.zeros(self.mag.shape)
            for j in range(self.y_size // l):
                for i in range(self.y_size // l):
                    dump_cell(i, j, self.mag_grad)


    def step(self, beta):
        # magnitude components are WAY more sensitive than dxn components
        self.dxn += self.dxn_grad * beta
        #self.mag += self.mag_grad * beta * 0.0001
        #self.mag = np.clip(self.mag, 0, 1)
        #self.mag += (np.ones((self.mag.shape)) - self.mag) * 0.01


    # it all boils down to this
    def descent(self, size):
        self.render()
        self.update_error()
        self.compute_gradient()
        self.step(size)

    def set_error(self, error):
        self.error = error

    def set_image(self, image):
        self.image = image

    def generate_input(self, f):
        self.image = f(self.main_x, self.main_y)

    def rotate(self, rotation):
        self.dxn = self.dxn + rotation

    def load(self, mag, dxn):
        self.mag = mag
        self.dxn = dxn


    def plaster(self, func):
        cx = self.dxn.shape[0] // 2
        cy = self.dxn.shape[1] // 2
        dx = self.image.shape[0] / 2
        dy = self.image.shape[1] / 2

        new_x, new_y = load_coordinates()

        # Shift
        # Stretch from [-1, 1] to [
        out = np.ones(self.dxn.shape)

        func = lambda x: x
        return func(out)




